if [ -f ~/.profile ]; then
    source ~/.profile
fi

# Load ~/.zprofile once from interactive shells that are not login shells
if [[ -o interactive ]] && [[ ! -o login ]]; then
  if [[ -z "${__ZPROFILE_LOADED-}" ]]; then
    __ZPROFILE_LOADED=1
    [[ -r ~/.zprofile ]] && source ~/.zprofile
  fi
fi

# Lines configured by zsh-newuser-install
HISTFILE=~/.histfile
HISTSIZE=1000
SAVEHIST=1000
bindkey -e
# End of lines configured by zsh-newuser-install

# The following lines were added by compinstall
zstyle :compinstall filename '/home/ubuntu/.zshrc'

autoload -Uz compinit
compinit
# End of lines added by compinstall

# Added by Zinit's installer
if [[ ! -f $HOME/.local/share/zinit/zinit.git/zinit.zsh ]]; then
    print -P "%F{33} %F{220}Installing %F{33}ZDHARMA-CONTINUUM%F{220} Initiative Plugin Manager (%F{33}zdharma-continuum/zinit%F{220})…%f"
    command mkdir -p "$HOME/.local/share/zinit" && command chmod g-rwX "$HOME/.local/share/zinit"
    command git clone https://github.com/zdharma-continuum/zinit "$HOME/.local/share/zinit/zinit.git" && \
        print -P "%F{33} %F{34}Installation successful.%f%b" || \
        print -P "%F{160} The clone has failed.%f%b"
fi

source "$HOME/.local/share/zinit/zinit.git/zinit.zsh"
autoload -Uz _zinit
(( ${+_comps} )) && _comps[zinit]=_zinit
# End of Zinit's installer chunk

# Zinit's config
## プロンプトテーマ sindresorhus/pure
zi ice pick"async.zsh" src"pure.zsh"
zi light sindresorhus/pure
## インタラクティブな補完
zinit light zsh-users/zsh-autosuggestions
## シンタックスハイライト
zinit light zdharma-continuum/fast-syntax-highlighting
# End of Zinit's config

# PATH
export PATH="$HOME/.local/share/mise/shims:$PATH"
export BUN_INSTALL="$HOME/.bun"
export PATH="$BUN_INSTALL/bin:$PATH"
export PNPM_HOME="$HOME/.local/share/pnpm"
export PATH="$PNPM_HOME:$PATH"
[[ ":$PATH:" != *":$PNPM_HOME:"* ]] && export PATH="$PATH:$PNPM_HOME"
if [ -f /home/linuxbrew/.linuxbrew/bin/brew ]; then
  eval "$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)"
fi
export PATH="$PATH:$HOME/apps"
export PATH="$PATH:$HOME/.remote-code/bin"
export PATH="$HOME/.local/bin:$PATH"
export ANDROID_SDK_ROOT="$HOME/Android/Sdk"
export ANDROID_NDK_HOME="$ANDROID_SDK_ROOT/ndk/27.3.13750724"
export ANDROID_HOME="$ANDROID_SDK_ROOT"

# Secret CLI completion (legacy fallback)
if command -v op &> /dev/null; then
  eval "$(op completion zsh)"; compdef _op op
fi

# Secret references (non-secret) for runtime resolution.
# PASS_MIGRATION_MODE:
# - native (default): prefer pass:// refs and ~/.config/proton-pass/*.env
# - legacy: prefer op:// refs and ~/.config/op/*.env
export PASS_MIGRATION_MODE="${PASS_MIGRATION_MODE:-native}"

# Proton Pass references
export ANTHROPIC_AUTH_TOKEN_PASS_REF="pass://CLI/Zai Key OpenClaw/credential"
export GOG_KEYRING_PASSWORD_PASS_REF="pass://CLI/GOG_KEYRING_PASSWORD/credential"
export CONTEXT7_API_KEY_PASS_REF="pass://CLI/context7-api-key/credential"
export PUSHOVER_TOKEN_PASS_REF="pass://CLI/pushover-codex/z6deozj7hxngryx3ldp3sk66wq"
export PUSHOVER_USER_PASS_REF="pass://CLI/pushover-codex/qoludfuoi6sogbwgfcd3fibgdi"

# 1Password references (legacy fallback)
export ANTHROPIC_AUTH_TOKEN_OP_REF="op://CLI/Zai Key OpenClaw/credential"
export GOG_KEYRING_PASSWORD_OP_REF="op://CLI/GOG_KEYRING_PASSWORD/credential"
export CONTEXT7_API_KEY_OP_REF="op://CLI/context7-api-key/credential"
export PUSHOVER_TOKEN_OP_REF="op://CLI/pushover-codex/z6deozj7hxngryx3ldp3sk66wq"
export PUSHOVER_USER_OP_REF="op://CLI/pushover-codex/qoludfuoi6sogbwgfcd3fibgdi"

# Backward-compatible generic names used by scripts and wrappers.
export ANTHROPIC_AUTH_TOKEN_REF="$ANTHROPIC_AUTH_TOKEN_PASS_REF"
export GOG_KEYRING_PASSWORD_REF="$GOG_KEYRING_PASSWORD_PASS_REF"
export CONTEXT7_API_KEY_REF="$CONTEXT7_API_KEY_PASS_REF"
export PUSHOVER_TOKEN_REF="$PUSHOVER_TOKEN_PASS_REF"
export PUSHOVER_USER_REF="$PUSHOVER_USER_PASS_REF"

# Load Proton Pass key material from a local-only file (not in chezmoi).
if [ -f "$HOME/.config/proton-pass/key.env" ]; then
  . "$HOME/.config/proton-pass/key.env"
fi

# Legacy: load OP service account token from a local-only file (not in chezmoi).
if [ -f "$HOME/.config/op/service-account.env" ]; then
  . "$HOME/.config/op/service-account.env"
fi

# Cargo
if [ -f "$HOME/.cargo/env" ]; then
  . "$HOME/.cargo/env"
fi

# Phantom
if command -v phantom &> /dev/null; then
  eval "$(phantom completion zsh)"
fi

# Functions
function google() {
  gemini -p "指定したクエリを検索し、要約して。<query>$1</query>"
}

secret_migration_mode() {
  if [ "${PASS_MIGRATION_MODE-}" = "legacy" ]; then
    printf '%s' "legacy"
  else
    printf '%s' "native"
  fi
}

secret_ref_cli() {
  local ref="$1"
  case "$ref" in
    pass://*) printf '%s' "pass" ;;
    op://*) printf '%s' "op" ;;
    *) printf '%s' "" ;;
  esac
}

select_secret_ref() {
  local pass_ref="$1"
  local op_ref="$2"
  local label="$3"
  local mode
  local primary
  local secondary

  mode="$(secret_migration_mode)"
  if [ "$mode" = "legacy" ]; then
    primary="$op_ref"
    secondary="$pass_ref"
  else
    primary="$pass_ref"
    secondary="$op_ref"
  fi

  if [ -n "$primary" ]; then
    printf '%s' "$primary"
    return 0
  fi

  if [ -n "$secondary" ]; then
    printf '%s' "$secondary"
    return 0
  fi

  echo "$label has no configured secret reference." >&2
  return 1
}

select_secret_env_file() {
  local pass_file="$1"
  local op_file="$2"
  local label="$3"
  local mode
  local primary
  local secondary

  mode="$(secret_migration_mode)"
  if [ "$mode" = "legacy" ]; then
    primary="$op_file"
    secondary="$pass_file"
  else
    primary="$pass_file"
    secondary="$op_file"
  fi

  if [ -f "$primary" ]; then
    printf '%s' "$primary"
    return 0
  fi

  if [ -f "$secondary" ]; then
    printf '%s' "$secondary"
    return 0
  fi

  echo "Missing env file for $label. Checked: $primary, $secondary" >&2
  return 1
}

require_secret_cli_runtime() {
  local caller="$1"
  local cli="$2"

  if ! command -v "$cli" >/dev/null 2>&1; then
    echo "$caller: $cli CLI is required." >&2
    return 1
  fi

  if [ "$cli" = "pass" ]; then
    if [ "${PROTON_PASS_KEY_PROVIDER-}" = "env" ] && [ -z "${PROTON_PASS_ENCRYPTION_KEY-}" ]; then
      echo "$caller: PROTON_PASS_ENCRYPTION_KEY must be set when PROTON_PASS_KEY_PROVIDER=env." >&2
      return 1
    fi
  fi
}

resolve_secret_ref() {
  local ref="$1"
  local label="$2"
  local value
  local cli

  if [ -z "$ref" ]; then
    echo "$label is empty." >&2
    return 1
  fi

  cli="$(secret_ref_cli "$ref")"
  if [ -z "$cli" ]; then
    echo "$label must start with pass:// or op://" >&2
    return 1
  fi

  require_secret_cli_runtime "resolve_secret_ref" "$cli" || return 1

  if [ "$cli" = "pass" ]; then
    value="$(pass show "$ref")" || {
      echo "failed to resolve $label from Proton Pass." >&2
      return 1
    }
  else
    value="$(op read "$ref")" || {
      echo "failed to resolve $label from 1Password." >&2
      return 1
    }
  fi

  if [ -z "$value" ]; then
    echo "$label resolved to an empty value." >&2
    return 1
  fi

  printf '%s' "$value"
}

env_file_value() {
  local env_file="$1"
  local key="$2"
  awk -F= -v key="$key" '
    $0 ~ "^[[:space:]]*"key"=" {
      val=substr($0, index($0, $2))
      gsub(/^[[:space:]]+|[[:space:]]+$/, "", val)
      print val
      exit
    }
  ' "$env_file"
}

resolve_secret_env_secret() {
  local env_file="$1"
  local key="$2"
  local label="$3"
  local ref

  if [ ! -f "$env_file" ]; then
    echo "Missing env file: $env_file" >&2
    return 1
  fi

  ref="$(env_file_value "$env_file" "$key")"
  if [ -z "$ref" ]; then
    echo "$label is missing in $env_file." >&2
    return 1
  fi

  resolve_secret_ref "$ref" "$label"
}

resolve_secret_value() {
  local pass_file="$1"
  local op_file="$2"
  local key="$3"
  local label="$4"
  local pass_ref="$5"
  local op_ref="$6"
  local mode
  local env_file
  local ref

  mode="$(secret_migration_mode)"

  if [ "$mode" = "legacy" ]; then
    if [ -f "$op_file" ]; then
      resolve_secret_env_secret "$op_file" "$key" "$label"
      return $?
    fi
    if [ -n "$op_ref" ]; then
      ref="$(select_secret_ref "$pass_ref" "$op_ref" "${label}_REF")" || return 1
      resolve_secret_ref "$ref" "$label"
      return $?
    fi
    if [ -f "$pass_file" ]; then
      resolve_secret_env_secret "$pass_file" "$key" "$label"
      return $?
    fi
  else
    if [ -f "$pass_file" ] || [ -f "$op_file" ]; then
      env_file="$(select_secret_env_file "$pass_file" "$op_file" "$label")" || return 1
      resolve_secret_env_secret "$env_file" "$key" "$label"
      return $?
    fi
  fi

  ref="$(select_secret_ref "$pass_ref" "$op_ref" "${label}_REF")" || return 1
  resolve_secret_ref "$ref" "$label"
}

glm() {
  local pass_env_file="$HOME/.config/proton-pass/claude.env"
  local op_env_file="$HOME/.config/op/claude.env"
  local -a cmd
  local token
  cmd=(claude --dangerously-skip-permissions "$@")

  if [ "$#" -eq 0 ] && [ ! -t 0 ]; then
    echo "glm: interactive mode requires a TTY. Use 'glm -p \"...\"' in non-interactive contexts." >&2
    return 2
  fi

  token="$(resolve_secret_value "$pass_env_file" "$op_env_file" "ANTHROPIC_AUTH_TOKEN" "ANTHROPIC_AUTH_TOKEN" "$ANTHROPIC_AUTH_TOKEN_PASS_REF" "$ANTHROPIC_AUTH_TOKEN_OP_REF")" || {
    echo "glm: failed to resolve ANTHROPIC_AUTH_TOKEN." >&2
    return 1
  }

  ANTHROPIC_BASE_URL="{{ .z_ai.endpoint }}" ANTHROPIC_AUTH_TOKEN="$token" "${cmd[@]}"
}

status_secret_value() {
  local pass_file="$1"
  local op_file="$2"
  local key="$3"
  local label="$4"
  local pass_ref="$5"
  local op_ref="$6"
  local mode
  local env_file
  local ref

  mode="$(secret_migration_mode)"

  if [ "$mode" = "legacy" ]; then
    if [ -f "$op_file" ]; then
      ref="$(env_file_value "$op_file" "$key")"
      if [ -z "$ref" ]; then
        echo "[ng] $label is missing in $op_file."
        return 1
      fi
      if resolve_secret_ref "$ref" "$label" >/dev/null 2>&1; then
        echo "[ok] $label resolves from $op_file."
        return 0
      fi
      echo "[ng] $label failed to resolve from $op_file ($ref)."
      return 1
    fi

    if [ -n "$op_ref" ]; then
      ref="$(select_secret_ref "$pass_ref" "$op_ref" "${label}_REF")" || return 1
      if resolve_secret_ref "$ref" "$label" >/dev/null 2>&1; then
        echo "[ok] $label resolves from shared ref ($ref)."
        return 0
      fi
      echo "[ng] $label failed to resolve from shared ref ($ref)."
      return 1
    fi

    if [ -f "$pass_file" ]; then
      ref="$(env_file_value "$pass_file" "$key")"
      if [ -z "$ref" ]; then
        echo "[ng] $label is missing in $pass_file."
        return 1
      fi
      if resolve_secret_ref "$ref" "$label" >/dev/null 2>&1; then
        echo "[ok] $label resolves from $pass_file."
        return 0
      fi
      echo "[ng] $label failed to resolve from $pass_file ($ref)."
      return 1
    fi
  else
    if [ -f "$pass_file" ] || [ -f "$op_file" ]; then
      env_file="$(select_secret_env_file "$pass_file" "$op_file" "$label")" || return 1
      ref="$(env_file_value "$env_file" "$key")"
      if [ -z "$ref" ]; then
        echo "[ng] $label is missing in $env_file."
        return 1
      fi

      if resolve_secret_ref "$ref" "$label" >/dev/null 2>&1; then
        echo "[ok] $label resolves from $env_file."
        return 0
      fi

      echo "[ng] $label failed to resolve from $env_file ($ref)."
      return 1
    fi
  fi

  ref="$(select_secret_ref "$pass_ref" "$op_ref" "${label}_REF")" || return 1
  if resolve_secret_ref "$ref" "$label" >/dev/null 2>&1; then
    echo "[ok] $label resolves from shared ref ($ref)."
    return 0
  fi

  echo "[ng] $label failed to resolve from shared ref ($ref)."
  return 1
}

status_shared_ref() {
  local pass_ref="$1"
  local op_ref="$2"
  local label="$3"
  local ref

  ref="$(select_secret_ref "$pass_ref" "$op_ref" "$label")" || return 1

  if resolve_secret_ref "$ref" "$label" >/dev/null 2>&1; then
    echo "[ok] $label resolves ($ref)."
    return 0
  fi

  echo "[ng] $label failed to resolve ($ref)."
  return 1
}

glm_status() {
  local mode
  local ok=0

  mode="$(secret_migration_mode)"
  echo "[ok] PASS_MIGRATION_MODE=$mode"

  if command -v pass >/dev/null 2>&1; then
    echo "[ok] pass CLI is installed."
    if [ "${PROTON_PASS_KEY_PROVIDER-}" = "env" ]; then
      echo "[ok] PROTON_PASS_KEY_PROVIDER=env"
    else
      echo "[ng] PROTON_PASS_KEY_PROVIDER should be 'env' (current: ${PROTON_PASS_KEY_PROVIDER:-unset})."
      ok=1
    fi

    if [ -n "${PROTON_PASS_ENCRYPTION_KEY-}" ]; then
      echo "[ok] PROTON_PASS_ENCRYPTION_KEY is set."
    else
      echo "[ng] PROTON_PASS_ENCRYPTION_KEY is not set (expected in ~/.config/proton-pass/key.env)."
      ok=1
    fi
  else
    if [ "$mode" = "legacy" ]; then
      echo "[ok] pass CLI is not installed (legacy mode using op:// fallback)."
    else
      echo "[ng] pass CLI is not installed."
      ok=1
    fi
  fi

  if status_secret_value "$HOME/.config/proton-pass/claude.env" "$HOME/.config/op/claude.env" "ANTHROPIC_AUTH_TOKEN" "ANTHROPIC_AUTH_TOKEN" "$ANTHROPIC_AUTH_TOKEN_PASS_REF" "$ANTHROPIC_AUTH_TOKEN_OP_REF"; then
    true
  else
    ok=1
  fi

  if status_secret_value "$HOME/.config/proton-pass/gog.env" "$HOME/.config/op/gog.env" "GOG_KEYRING_PASSWORD" "GOG_KEYRING_PASSWORD" "$GOG_KEYRING_PASSWORD_PASS_REF" "$GOG_KEYRING_PASSWORD_OP_REF"; then
    true
  else
    ok=1
  fi

  if status_shared_ref "$CONTEXT7_API_KEY_PASS_REF" "$CONTEXT7_API_KEY_OP_REF" "CONTEXT7_API_KEY_REF"; then
    true
  else
    ok=1
  fi

  if status_shared_ref "$PUSHOVER_TOKEN_PASS_REF" "$PUSHOVER_TOKEN_OP_REF" "PUSHOVER_TOKEN_REF"; then
    true
  else
    ok=1
  fi

  if status_shared_ref "$PUSHOVER_USER_PASS_REF" "$PUSHOVER_USER_OP_REF" "PUSHOVER_USER_REF"; then
    true
  else
    ok=1
  fi

  return "$ok"
}

gog_op() {
  local pass_env_file="$HOME/.config/proton-pass/gog.env"
  local op_env_file="$HOME/.config/op/gog.env"
  local keyring_password

  if ! command -v gog >/dev/null 2>&1; then
    echo "gog CLI is required." >&2
    return 1
  fi

  keyring_password="$(resolve_secret_value "$pass_env_file" "$op_env_file" "GOG_KEYRING_PASSWORD" "GOG_KEYRING_PASSWORD" "$GOG_KEYRING_PASSWORD_PASS_REF" "$GOG_KEYRING_PASSWORD_OP_REF")" || {
    echo "gog: failed to resolve GOG_KEYRING_PASSWORD." >&2
    return 1
  }

  GOG_KEYRING_PASSWORD="$keyring_password" gog "$@"
}

cx() {
  local context7_key
  local context7_ref

  context7_ref="$(select_secret_ref "$CONTEXT7_API_KEY_PASS_REF" "$CONTEXT7_API_KEY_OP_REF" "CONTEXT7_API_KEY_REF")" || return 1

  context7_key="$(resolve_secret_ref "$context7_ref" "CONTEXT7_API_KEY_REF")" || {
    echo "cx: failed to resolve CONTEXT7_API_KEY." >&2
    return 1
  }

  CONTEXT7_API_KEY="$context7_key" codex "$@"
}

# Alias
alias cl="clear"
alias zll="zellij"
alias zla="zellij a"
alias ..="cd ../"
alias ...="cd ../../"
alias cc="claude"
alias ccd="claude --dangerously-skip-permissions"
alias glms="glm_status"
alias gog="gog_op"
alias mr="mise run"
alias phc="phantom create"
alias phd="phantom delete"
alias phs="phantom shell"
alias python="python3"
alias opencode="OPENCODE_EXPERIMENTAL_PLAN_MODE=true opencode"
