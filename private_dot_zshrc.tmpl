
# Secret references (non-secret) for runtime resolution.
export ANTHROPIC_AUTH_TOKEN_PASS_REF="pass://CLI/Zai Key OpenClaw/credential"
export GOG_KEYRING_PASSWORD_PASS_REF="pass://CLI/GOG_KEYRING_PASSWORD/credential"
export CONTEXT7_API_KEY_PASS_REF="pass://CLI/context7-api-key/credential"
export PUSHOVER_TOKEN_PASS_REF="pass://CLI/pushover-codex/z6deozj7hxngryx3ldp3sk66wq"
export PUSHOVER_USER_PASS_REF="pass://CLI/pushover-codex/qoludfuoi6sogbwgfcd3fibgdi"

# Backward-compatible generic names used by scripts and wrappers.
export ANTHROPIC_AUTH_TOKEN_REF="$ANTHROPIC_AUTH_TOKEN_PASS_REF"
export GOG_KEYRING_PASSWORD_REF="$GOG_KEYRING_PASSWORD_PASS_REF"
export CONTEXT7_API_KEY_REF="$CONTEXT7_API_KEY_PASS_REF"
export PUSHOVER_TOKEN_REF="$PUSHOVER_TOKEN_PASS_REF"
export PUSHOVER_USER_REF="$PUSHOVER_USER_PASS_REF"

# Load Proton Pass key material from a local-only file (not in chezmoi).
if [ -f "$HOME/.config/proton-pass/key.env" ]; then
  . "$HOME/.config/proton-pass/key.env"
fi

# Cargo
if [ -f "$HOME/.cargo/env" ]; then
  . "$HOME/.cargo/env"
fi

# Phantom
if command -v phantom &> /dev/null; then
  eval "$(phantom completion zsh)"
fi

# Functions
function google() {
  gemini -p "指定したクエリを検索し、要約して。<query>$1</query>"
}

secret_ref_cli() {
  local ref="$1"
  case "$ref" in
    pass://*) printf '%s' "pass-cli" ;;
    *) printf '%s' "" ;;
  esac
}

select_secret_ref() {
  local pass_ref="$1"
  local label="$2"

  if [ -n "$pass_ref" ]; then
    printf '%s' "$pass_ref"
    return 0
  fi

  echo "$label has no configured secret reference." >&2
  return 1
}

select_secret_env_file() {
  local pass_file="$1"
  local label="$2"

  if [ -f "$pass_file" ]; then
    printf '%s' "$pass_file"
    return 0
  fi

  echo "Missing env file for $label. Checked: $pass_file" >&2
  return 1
}

require_pass_cli_runtime() {
  local caller="$1"

  if ! command -v pass-cli >/dev/null 2>&1; then
    echo "$caller: pass-cli is required." >&2
    return 1
  fi

  if [ "${PROTON_PASS_KEY_PROVIDER-}" = "env" ] && [ -z "${PROTON_PASS_ENCRYPTION_KEY-}" ]; then
    echo "$caller: PROTON_PASS_ENCRYPTION_KEY must be set when PROTON_PASS_KEY_PROVIDER=env." >&2
    return 1
  fi
}

resolve_secret_ref() {
  local ref="$1"
  local label="$2"
  local value

  if [ -z "$ref" ]; then
    echo "$label is empty." >&2
    return 1
  fi

  if [ "$(secret_ref_cli "$ref")" != "pass-cli" ]; then
    echo "$label must start with pass://." >&2
    return 1
  fi

  require_pass_cli_runtime "resolve_secret_ref" || return 1

  value="$(pass-cli show "$ref")" || {
    echo "failed to resolve $label from Proton Pass." >&2
    return 1
  }

  if [ -z "$value" ]; then
    echo "$label resolved to an empty value." >&2
    return 1
  fi

  printf '%s' "$value"
}

env_file_value() {
  local env_file="$1"
  local key="$2"
  awk -F= -v key="$key" '
    $0 ~ "^[[:space:]]*"key"=" {
      val=substr($0, index($0, $2))
      gsub(/^[[:space:]]+|[[:space:]]+$/, "", val)
      print val
      exit
    }
  ' "$env_file"
}

resolve_secret_env_secret() {
  local env_file="$1"
  local key="$2"
  local label="$3"
  local ref

  if [ ! -f "$env_file" ]; then
    echo "Missing env file: $env_file" >&2
    return 1
  fi

  ref="$(env_file_value "$env_file" "$key")"
  if [ -z "$ref" ]; then
    echo "$label is missing in $env_file." >&2
    return 1
  fi

  resolve_secret_ref "$ref" "$label"
}

resolve_secret_value() {
  local pass_file="$1"
  local key="$2"
  local label="$3"
  local pass_ref="$4"
  local env_file

  if [ -f "$pass_file" ]; then
    env_file="$(select_secret_env_file "$pass_file" "$label")" || return 1
    resolve_secret_env_secret "$env_file" "$key" "$label"
    return $?
  fi

  resolve_secret_ref "$(select_secret_ref "$pass_ref" "${label}_REF")" "$label"
}

glm() {
  local pass_env_file="$HOME/.config/proton-pass/claude.env"
  local -a cmd
  local token
  cmd=(claude --dangerously-skip-permissions "$@")

  if [ "$#" -eq 0 ] && [ ! -t 0 ]; then
    echo "glm: interactive mode requires a TTY. Use 'glm -p \"...\"' in non-interactive contexts." >&2
    return 2
  fi

  token="$(resolve_secret_value "$pass_env_file" "ANTHROPIC_AUTH_TOKEN" "ANTHROPIC_AUTH_TOKEN" "$ANTHROPIC_AUTH_TOKEN_PASS_REF")" || {
    echo "glm: failed to resolve ANTHROPIC_AUTH_TOKEN." >&2
    return 1
  }

  ANTHROPIC_BASE_URL="{{ .z_ai.endpoint }}" ANTHROPIC_AUTH_TOKEN="$token" "${cmd[@]}"
}

status_secret_value() {
  local pass_file="$1"
  local key="$2"
  local label="$3"
  local pass_ref="$4"
  local env_file
  local ref

  if [ -f "$pass_file" ]; then
    env_file="$(select_secret_env_file "$pass_file" "$label")" || return 1
    ref="$(env_file_value "$env_file" "$key")"

    if [ -z "$ref" ]; then
      echo "[ng] $label is missing in $env_file."
      return 1
    fi

    if resolve_secret_ref "$ref" "$label" >/dev/null 2>&1; then
      echo "[ok] $label resolves from $env_file."
      return 0
    fi

    echo "[ng] $label failed to resolve from $env_file ($ref)."
    return 1
  fi

  ref="$(select_secret_ref "$pass_ref" "${label}_REF")" || return 1
  if resolve_secret_ref "$ref" "$label" >/dev/null 2>&1; then
    echo "[ok] $label resolves from shared ref ($ref)."
    return 0
  fi

  echo "[ng] $label failed to resolve from shared ref ($ref)."
  return 1
}

status_shared_ref() {
  local pass_ref="$1"
  local label="$2"
  local ref

  ref="$(select_secret_ref "$pass_ref" "$label")" || return 1

  if resolve_secret_ref "$ref" "$label" >/dev/null 2>&1; then
    echo "[ok] $label resolves ($ref)."
    return 0
  fi

  echo "[ng] $label failed to resolve ($ref)."
  return 1
}

secrets_status_core() {
  local ok=0

  if command -v pass-cli >/dev/null 2>&1; then
    echo "[ok] pass-cli is installed."
  else
    echo "[ng] pass-cli is not installed."
    ok=1
  fi

  if [ "${PROTON_PASS_KEY_PROVIDER-}" = "env" ]; then
    echo "[ok] PROTON_PASS_KEY_PROVIDER=env"
  else
    echo "[ng] PROTON_PASS_KEY_PROVIDER should be 'env' (current: ${PROTON_PASS_KEY_PROVIDER:-unset})."
    ok=1
  fi

  if [ -n "${PROTON_PASS_ENCRYPTION_KEY-}" ]; then
    echo "[ok] PROTON_PASS_ENCRYPTION_KEY is set."
  else
    echo "[ng] PROTON_PASS_ENCRYPTION_KEY is not set (expected in ~/.config/proton-pass/key.env)."
    ok=1
  fi

  if status_secret_value "$HOME/.config/proton-pass/claude.env" "ANTHROPIC_AUTH_TOKEN" "ANTHROPIC_AUTH_TOKEN" "$ANTHROPIC_AUTH_TOKEN_PASS_REF"; then
    true
  else
    ok=1
  fi

  return "$ok"
}

secrets_status() {
  local ok=0

  if secrets_status_core; then
    true
  else
    ok=1
  fi

  if status_secret_value "$HOME/.config/proton-pass/gog.env" "GOG_KEYRING_PASSWORD" "GOG_KEYRING_PASSWORD" "$GOG_KEYRING_PASSWORD_PASS_REF"; then
    true
  else
    ok=1
  fi

  if status_shared_ref "$CONTEXT7_API_KEY_PASS_REF" "CONTEXT7_API_KEY_REF"; then
    true
  else
    ok=1
  fi

  if status_shared_ref "$PUSHOVER_TOKEN_PASS_REF" "PUSHOVER_TOKEN_REF"; then
    true
  else
    ok=1
  fi

  if status_shared_ref "$PUSHOVER_USER_PASS_REF" "PUSHOVER_USER_REF"; then
    true
  else
    ok=1
  fi

  return "$ok"
}

gog_op() {
  local pass_env_file="$HOME/.config/proton-pass/gog.env"
  local keyring_password

  if ! command -v gog >/dev/null 2>&1; then
    echo "gog CLI is required." >&2
    return 1
  fi

  keyring_password="$(resolve_secret_value "$pass_env_file" "GOG_KEYRING_PASSWORD" "GOG_KEYRING_PASSWORD" "$GOG_KEYRING_PASSWORD_PASS_REF")" || {
    echo "gog: failed to resolve GOG_KEYRING_PASSWORD." >&2
    return 1
  }

  GOG_KEYRING_PASSWORD="$keyring_password" gog "$@"
}

cx() {
  local context7_ref
  local context7_key

  context7_ref="$(select_secret_ref "$CONTEXT7_API_KEY_PASS_REF" "CONTEXT7_API_KEY_REF")" || return 1

  context7_key="$(resolve_secret_ref "$context7_ref" "CONTEXT7_API_KEY_REF")" || {
    echo "cx: failed to resolve CONTEXT7_API_KEY." >&2
    return 1
  }

  CONTEXT7_API_KEY="$context7_key" codex "$@"
}

# Alias
alias cl="clear"
alias zll="zellij"
alias zla="zellij a"
alias ..="cd ../"
alias ...="cd ../../"
alias cc="claude"
alias ccd="claude --dangerously-skip-permissions"
alias secrets-status="secrets_status"
alias gog="gog_op"
alias mr="mise run"
alias phc="phantom create"
alias phd="phantom delete"
alias phs="phantom shell"
alias python="python3"
alias opencode="OPENCODE_EXPERIMENTAL_PLAN_MODE=true opencode"
