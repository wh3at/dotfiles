if [ -f ~/.profile ]; then
    source ~/.profile
fi

# Load ~/.zprofile once from interactive shells that are not login shells
if [[ -o interactive ]] && [[ ! -o login ]]; then
  if [[ -z "${__ZPROFILE_LOADED-}" ]]; then
    __ZPROFILE_LOADED=1
    [[ -r ~/.zprofile ]] && source ~/.zprofile
  fi
fi

# Lines configured by zsh-newuser-install
HISTFILE=~/.histfile
HISTSIZE=1000
SAVEHIST=1000
bindkey -e
# End of lines configured by zsh-newuser-install

# The following lines were added by compinstall
zstyle :compinstall filename '/home/ubuntu/.zshrc'

autoload -Uz compinit
compinit
# End of lines added by compinstall

# Added by Zinit's installer
if [[ ! -f $HOME/.local/share/zinit/zinit.git/zinit.zsh ]]; then
    print -P "%F{33} %F{220}Installing %F{33}ZDHARMA-CONTINUUM%F{220} Initiative Plugin Manager (%F{33}zdharma-continuum/zinit%F{220})…%f"
    command mkdir -p "$HOME/.local/share/zinit" && command chmod g-rwX "$HOME/.local/share/zinit"
    command git clone https://github.com/zdharma-continuum/zinit "$HOME/.local/share/zinit/zinit.git" && \
        print -P "%F{33} %F{34}Installation successful.%f%b" || \
        print -P "%F{160} The clone has failed.%f%b"
fi

source "$HOME/.local/share/zinit/zinit.git/zinit.zsh"
autoload -Uz _zinit
(( ${+_comps} )) && _comps[zinit]=_zinit
# End of Zinit's installer chunk

# Zinit's config
## プロンプトテーマ sindresorhus/pure
zi ice pick"async.zsh" src"pure.zsh"
zi light sindresorhus/pure
## インタラクティブな補完
zinit light zsh-users/zsh-autosuggestions
## シンタックスハイライト
zinit light zdharma-continuum/fast-syntax-highlighting
# End of Zinit's config

# PATH
export PATH="$HOME/.local/share/mise/shims:$PATH"
export BUN_INSTALL="$HOME/.bun"
export PATH="$BUN_INSTALL/bin:$PATH"
export PNPM_HOME="$HOME/.local/share/pnpm"
export PATH="$PNPM_HOME:$PATH"
[[ ":$PATH:" != *":$PNPM_HOME:"* ]] && export PATH="$PATH:$PNPM_HOME"
if [ -f /home/linuxbrew/.linuxbrew/bin/brew ]; then
  eval "$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)"
fi
export PATH="$PATH:$HOME/apps"
export PATH="$PATH:$HOME/.remote-code/bin"
export PATH="$HOME/.local/bin:$PATH"
export ANDROID_SDK_ROOT="$HOME/Android/Sdk"
export ANDROID_NDK_HOME="$ANDROID_SDK_ROOT/ndk/27.3.13750724"
export ANDROID_HOME="$ANDROID_SDK_ROOT"

# 1Password
if command -v op &> /dev/null; then
  eval "$(op completion zsh)"; compdef _op op
fi

# 1Password secret references (non-secret) for runtime resolution.
export CONTEXT7_API_KEY_REF="op://CLI/context7-api-key/credential"
export PUSHOVER_TOKEN_OP_REF="op://CLI/pushover-codex/z6deozj7hxngryx3ldp3sk66wq"
export PUSHOVER_USER_OP_REF="op://CLI/pushover-codex/qoludfuoi6sogbwgfcd3fibgdi"

# Load OP service account token from a local-only file (not in chezmoi).
if [ -f "$HOME/.config/op/service-account.env" ]; then
  . "$HOME/.config/op/service-account.env"
fi

# Cargo
if [ -f "$HOME/.cargo/env" ]; then
  . "$HOME/.cargo/env"
fi

# Phantom
if command -v phantom &> /dev/null; then
  eval "$(phantom completion zsh)"
fi

# Functions
function google() {
  gemini -p "指定したクエリを検索し、要約して。<query>$1</query>"
}

require_op_runtime() {
  local caller="$1"
  if ! command -v op >/dev/null 2>&1; then
    echo "$caller: op CLI is required." >&2
    return 1
  fi

  if [ -z "${OP_SERVICE_ACCOUNT_TOKEN-}" ]; then
    echo "$caller: OP_SERVICE_ACCOUNT_TOKEN is not set. Add export to ~/.config/op/service-account.env and source ~/.zshrc." >&2
    return 1
  fi
}

resolve_op_ref() {
  local ref="$1"
  local label="$2"
  local value

  if [ -z "$ref" ]; then
    echo "$label is empty." >&2
    return 1
  fi

  value="$(op read "$ref")" || {
    echo "failed to resolve $label from 1Password." >&2
    return 1
  }

  if [ -z "$value" ]; then
    echo "$label resolved to an empty value." >&2
    return 1
  fi

  printf '%s' "$value"
}

op_env_value() {
  local env_file="$1"
  local key="$2"
  awk -F= -v key="$key" '
    $0 ~ "^[[:space:]]*"key"=" {
      val=substr($0, index($0, $2))
      gsub(/^[[:space:]]+|[[:space:]]+$/, "", val)
      print val
      exit
    }
  ' "$env_file"
}

resolve_op_env_secret() {
  local env_file="$1"
  local key="$2"
  local label="$3"
  local ref

  if [ ! -f "$env_file" ]; then
    echo "Missing env file: $env_file" >&2
    return 1
  fi

  ref="$(op_env_value "$env_file" "$key")"
  if [ -z "$ref" ]; then
    echo "$label is missing in $env_file." >&2
    return 1
  fi

  resolve_op_ref "$ref" "$label"
}

glm() {
  local env_file="$HOME/.config/op/claude.env"
  local -a cmd
  local token
  cmd=(claude --dangerously-skip-permissions "$@")

  if [ "$#" -eq 0 ] && [ ! -t 0 ]; then
    echo "glm: interactive mode requires a TTY. Use 'glm -p \"...\"' in non-interactive contexts." >&2
    return 2
  fi

  require_op_runtime "glm" || return 1

  token="$(resolve_op_env_secret "$env_file" "ANTHROPIC_AUTH_TOKEN" "ANTHROPIC_AUTH_TOKEN")" || {
    echo "glm: failed to resolve ANTHROPIC_AUTH_TOKEN." >&2
    return 1
  }

  ANTHROPIC_BASE_URL="{{ .z_ai.endpoint }}" ANTHROPIC_AUTH_TOKEN="$token" "${cmd[@]}"
}

glm_status() {
  local env_file="$HOME/.config/op/claude.env"
  local gog_env_file="$HOME/.config/op/gog.env"
  local ok=0
  local token_ref
  local gog_ref
  local ref_name
  local ref_value

  if command -v op >/dev/null 2>&1; then
    echo "[ok] op CLI is installed."
  else
    echo "[ng] op CLI is not installed."
    ok=1
  fi

  if [ -n "${OP_SERVICE_ACCOUNT_TOKEN-}" ]; then
    echo "[ok] OP_SERVICE_ACCOUNT_TOKEN is set."
  else
    echo "[ng] OP_SERVICE_ACCOUNT_TOKEN is not set (expected in ~/.config/op/service-account.env)."
    ok=1
  fi

  if [ -f "$env_file" ]; then
    echo "[ok] $env_file exists."
    if grep -Eq "<[^>]+>" "$env_file"; then
      echo "[ng] $env_file still contains placeholder segments like <item>/<field>."
      ok=1
    else
      echo "[ok] $env_file has a concrete secret reference."
      token_ref="$(awk -F= '/^ANTHROPIC_AUTH_TOKEN=/{print substr($0, index($0,$2)); exit}' "$env_file")"
      if [ -z "$token_ref" ]; then
        echo "[ng] ANTHROPIC_AUTH_TOKEN entry is missing in $env_file."
        ok=1
      elif op read "$token_ref" >/dev/null 2>&1; then
        echo "[ok] ANTHROPIC_AUTH_TOKEN reference resolves in 1Password."
      else
        echo "[ng] ANTHROPIC_AUTH_TOKEN reference does not resolve: $token_ref"
        ok=1
      fi
    fi
  else
    echo "[ng] Missing env file: $env_file"
    ok=1
  fi

  if [ -f "$gog_env_file" ]; then
    echo "[ok] $gog_env_file exists."
    gog_ref="$(awk -F= '/^GOG_KEYRING_PASSWORD=/{print substr($0, index($0,$2)); exit}' "$gog_env_file")"
    if [ -z "$gog_ref" ]; then
      echo "[ng] GOG_KEYRING_PASSWORD entry is missing in $gog_env_file."
      ok=1
    elif op read "$gog_ref" >/dev/null 2>&1; then
      echo "[ok] GOG_KEYRING_PASSWORD reference resolves in 1Password."
    else
      echo "[ng] GOG_KEYRING_PASSWORD reference does not resolve: $gog_ref"
      ok=1
    fi
  else
    echo "[ng] Missing env file: $gog_env_file"
    ok=1
  fi

  for ref_name in CONTEXT7_API_KEY_REF PUSHOVER_TOKEN_OP_REF PUSHOVER_USER_OP_REF; do
    ref_value="${(P)ref_name}"
    if [ -z "$ref_value" ]; then
      echo "[ng] $ref_name is not set in ~/.zshrc."
      ok=1
    elif op read "$ref_value" >/dev/null 2>&1; then
      echo "[ok] $ref_name resolves in 1Password."
    else
      echo "[ng] $ref_name does not resolve: $ref_value"
      ok=1
    fi
  done

  return "$ok"
}

gog_op() {
  local env_file="$HOME/.config/op/gog.env"
  local keyring_password

  if ! command -v gog >/dev/null 2>&1; then
    echo "gog CLI is required." >&2
    return 1
  fi

  require_op_runtime "gog" || return 1

  keyring_password="$(resolve_op_env_secret "$env_file" "GOG_KEYRING_PASSWORD" "GOG_KEYRING_PASSWORD")" || {
    echo "gog: failed to resolve GOG_KEYRING_PASSWORD." >&2
    return 1
  }

  GOG_KEYRING_PASSWORD="$keyring_password" gog "$@"
}

cx() {
  local context7_key

  require_op_runtime "cx" || return 1

  if [ -z "${CONTEXT7_API_KEY_REF-}" ]; then
    echo "cx: CONTEXT7_API_KEY_REF is not set in ~/.zshrc." >&2
    return 1
  fi

  context7_key="$(resolve_op_ref "$CONTEXT7_API_KEY_REF" "CONTEXT7_API_KEY_REF")" || {
    echo "cx: failed to resolve CONTEXT7_API_KEY." >&2
    return 1
  }

  CONTEXT7_API_KEY="$context7_key" codex "$@"
}

# Alias
alias cl="clear"
alias zll="zellij"
alias zla="zellij a"
alias ..="cd ../"
alias ...="cd ../../"
alias cc="claude"
alias ccd="claude --dangerously-skip-permissions"
alias glms="glm_status"
alias gog="gog_op"
alias mr="mise run"
alias phc="phantom create"
alias phd="phantom delete"
alias phs="phantom shell"
alias python="python3"
alias opencode="OPENCODE_EXPERIMENTAL_PLAN_MODE=true opencode"

# bun completions
[ -s "$HOME/.bun/_bun" ] && source "$HOME/.bun/_bun"

# pnpm completions
if command -v pnpm &> /dev/null; then
  eval "$(pnpm completion zsh)";
fi

# jujutsu completions
if command -v jj >/dev/null 2>&1; then
  source <(COMPLETE=zsh jj)
fi

# neovim
if [ -f "$HOME/apps/nvim-linux-arm64.appimage" ]; then
  alias nvim="$HOME/apps/nvim-linux-arm64.appimage"
fi

# Zellij custom
zll_new_git_wt() {
  # zellij 内でなければ終了
  if [ -z "${ZELLIJ-}" ]; then
    echo 'zj_new_tab: must be run inside zellij' >&2
    return 1
  fi

  # ブランチ名を受け取る
  local name="$1"

  if [ -z "$name" ]; then
    printf 'tab name: '
    read -r name || return 1
  fi

  [ -z "$name" ] && return 1

  phantom create "feature/$name"

  # Layout の作業領域が2ペイン前提
  local cwd="$PWD"
  zellij action new-tab --name "$name" --layout main --cwd "$cwd"

  zellij action write-chars "phantom shell feature/$name"
  zellij action write 13

  zellij action focus-next-pane
  zellij action write-chars "phantom shell feature/$name"
  zellij action write 13

  zellij action focus-previous-pane
  zellij action write-chars "codex"
  zellij action write 13
}
