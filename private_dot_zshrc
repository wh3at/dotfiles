if [ -f ~/.profile ]; then
    source ~/.profile
fi

# Load ~/.zprofile once from interactive shells that are not login shells
if [[ -o interactive ]] && [[ ! -o login ]]; then
  if [[ -z "${__ZPROFILE_LOADED-}" ]]; then
    __ZPROFILE_LOADED=1
    [[ -r ~/.zprofile ]] && source ~/.zprofile
  fi
fi

# Lines configured by zsh-newuser-install
HISTFILE=~/.histfile
HISTSIZE=1000
SAVEHIST=1000
bindkey -e
# End of lines configured by zsh-newuser-install

# The following lines were added by compinstall
zstyle :compinstall filename '/home/ubuntu/.zshrc'

autoload -Uz compinit
compinit
# End of lines added by compinstall

# Added by Zinit's installer
if [[ ! -f $HOME/.local/share/zinit/zinit.git/zinit.zsh ]]; then
    print -P "%F{33} %F{220}Installing %F{33}ZDHARMA-CONTINUUM%F{220} Initiative Plugin Manager (%F{33}zdharma-continuum/zinit%F{220})…%f"
    command mkdir -p "$HOME/.local/share/zinit" && command chmod g-rwX "$HOME/.local/share/zinit"
    command git clone https://github.com/zdharma-continuum/zinit "$HOME/.local/share/zinit/zinit.git" && \
        print -P "%F{33} %F{34}Installation successful.%f%b" || \
        print -P "%F{160} The clone has failed.%f%b"
fi

source "$HOME/.local/share/zinit/zinit.git/zinit.zsh"
autoload -Uz _zinit
(( ${+_comps} )) && _comps[zinit]=_zinit
# End of Zinit's installer chunk

# Zinit's config
## プロンプトテーマ sindresorhus/pure
zi ice pick"async.zsh" src"pure.zsh"
zi light sindresorhus/pure
## インタラクティブな補完
zinit light zsh-users/zsh-autosuggestions
## シンタックスハイライト
zinit light zdharma-continuum/fast-syntax-highlighting
# End of Zinit's config

# PATH
export PATH="$HOME/.local/share/mise/shims:$PATH"
export BUN_INSTALL="$HOME/.bun"
export PATH="$BUN_INSTALL/bin:$PATH"
export PNPM_HOME="$HOME/.local/share/pnpm"
export PATH="$PNPM_HOME:$PATH"
[[ ":$PATH:" != *":$PNPM_HOME:"* ]] && export PATH="$PATH:$PNPM_HOME"
if [ -f /home/linuxbrew/.linuxbrew/bin/brew ]; then
  eval "$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)"
fi
export PATH="$PATH:$HOME/apps"
export PATH="$PATH:$HOME/.remote-code/bin"
export PATH="$HOME/.local/bin:$PATH"
export ANDROID_SDK_ROOT="$HOME/Android/Sdk"
export ANDROID_NDK_HOME="$ANDROID_SDK_ROOT/ndk/27.3.13750724"
export ANDROID_HOME="$ANDROID_SDK_ROOT"

# Secret references (non-secret) for runtime resolution.
export ANTHROPIC_AUTH_TOKEN_PASS_REF="pass://CLI/Zai Key OpenClaw/credential"
export GOG_KEYRING_PASSWORD_PASS_REF="pass://CLI/GOG_KEYRING_PASSWORD/認証情報"
export CONTEXT7_API_KEY_PASS_REF="pass://CLI/context7-api-key/APIキー"
export PUSHOVER_TOKEN_PASS_REF="pass://CLI/pushover-codex/z6deozj7hxngryx3ldp3sk66wq"
export PUSHOVER_USER_PASS_REF="pass://CLI/pushover-codex/qoludfuoi6sogbwgfcd3fibgdi"

# Backward-compatible generic names used by scripts and wrappers.
export ANTHROPIC_AUTH_TOKEN_REF="$ANTHROPIC_AUTH_TOKEN_PASS_REF"
export GOG_KEYRING_PASSWORD_REF="$GOG_KEYRING_PASSWORD_PASS_REF"
export CONTEXT7_API_KEY_REF="$CONTEXT7_API_KEY_PASS_REF"
export PUSHOVER_TOKEN_REF="$PUSHOVER_TOKEN_PASS_REF"
export PUSHOVER_USER_REF="$PUSHOVER_USER_PASS_REF"

# Proton Pass CLI storage backend.
# Prefer filesystem key provider on Linux to avoid keyring/env drift.
export PROTON_PASS_KEY_PROVIDER="${PROTON_PASS_KEY_PROVIDER:-fs}"

# Optional local-only overrides (not in chezmoi templates).
if [ -f "$HOME/.config/proton-pass/key.env" ]; then
  . "$HOME/.config/proton-pass/key.env"
fi

# Cargo
if [ -f "$HOME/.cargo/env" ]; then
  . "$HOME/.cargo/env"
fi

# Phantom
if command -v phantom &> /dev/null; then
  eval "$(phantom completion zsh)"
fi

# Functions
function google() {
  gemini -p "指定したクエリを検索し、要約して。<query>$1</query>"
}

secret_ref_cli() {
  local ref="$1"
  case "$ref" in
    pass://*) printf '%s' "pass-cli" ;;
    *) printf '%s' "" ;;
  esac
}

select_secret_ref() {
  local pass_ref="$1"
  local label="$2"

  if [ -n "$pass_ref" ]; then
    printf '%s' "$pass_ref"
    return 0
  fi

  echo "$label has no configured secret reference." >&2
  return 1
}

select_secret_env_file() {
  local pass_file="$1"
  local label="$2"

  if [ -f "$pass_file" ]; then
    printf '%s' "$pass_file"
    return 0
  fi

  echo "Missing env file for $label. Checked: $pass_file" >&2
  return 1
}

require_pass_cli_runtime() {
  local caller="$1"

  if ! command -v pass-cli >/dev/null 2>&1; then
    echo "$caller: pass-cli is required." >&2
    return 1
  fi

  if [ -z "${PROTON_PASS_KEY_PROVIDER-}" ]; then
    echo "$caller: PROTON_PASS_KEY_PROVIDER is not set." >&2
    return 1
  fi
}

resolve_secret_ref() {
  local ref="$1"
  local label="$2"
  local value
  local tmp_env
  local run_status=0

  if [ -z "$ref" ]; then
    echo "$label is empty." >&2
    return 1
  fi

  if [ "$(secret_ref_cli "$ref")" != "pass-cli" ]; then
    echo "$label must start with pass://." >&2
    return 1
  fi

  require_pass_cli_runtime "resolve_secret_ref" || return 1

  tmp_env="$(mktemp)" || {
    echo "failed to create temporary env file for $label." >&2
    return 1
  }
  chmod 600 "$tmp_env"
  printf '__PASS_CLI_SECRET=%s\n' "$ref" > "$tmp_env"

  value="$(pass-cli run --env-file "$tmp_env" -- sh -c 'printf %s "$__PASS_CLI_SECRET"')" || run_status=$?
  rm -f "$tmp_env"

  if [ "$run_status" -ne 0 ]; then
    echo "failed to resolve $label from Proton Pass." >&2
    return 1
  fi

  if [ -z "$value" ]; then
    echo "$label resolved to an empty value." >&2
    return 1
  fi

  printf '%s' "$value"
}

env_file_value() {
  local env_file="$1"
  local key="$2"
  awk -F= -v key="$key" '
    $0 ~ "^[[:space:]]*"key"=" {
      val=substr($0, index($0, $2))
      gsub(/^[[:space:]]+|[[:space:]]+$/, "", val)
      print val
      exit
    }
  ' "$env_file"
}

resolve_secret_env_secret() {
  local env_file="$1"
  local key="$2"
  local label="$3"
  local ref

  if [ ! -f "$env_file" ]; then
    echo "Missing env file: $env_file" >&2
    return 1
  fi

  ref="$(env_file_value "$env_file" "$key")"
  if [ -z "$ref" ]; then
    echo "$label is missing in $env_file." >&2
    return 1
  fi

  resolve_secret_ref "$ref" "$label"
}

resolve_secret_value() {
  local pass_file="$1"
  local key="$2"
  local label="$3"
  local pass_ref="$4"
  local env_file

  if [ -f "$pass_file" ]; then
    env_file="$(select_secret_env_file "$pass_file" "$label")" || return 1
    resolve_secret_env_secret "$env_file" "$key" "$label"
    return $?
  fi

  resolve_secret_ref "$(select_secret_ref "$pass_ref" "${label}_REF")" "$label"
}

glm() {
  local pass_env_file="$HOME/.config/proton-pass/claude.env"
  local -a cmd
  local token
  cmd=(claude --dangerously-skip-permissions "$@")

  if [ "$#" -eq 0 ] && [ ! -t 0 ]; then
    echo "glm: interactive mode requires a TTY. Use 'glm -p \"...\"' in non-interactive contexts." >&2
    return 2
  fi

  token="$(resolve_secret_value "$pass_env_file" "ANTHROPIC_AUTH_TOKEN" "ANTHROPIC_AUTH_TOKEN" "$ANTHROPIC_AUTH_TOKEN_PASS_REF")" || {
    echo "glm: failed to resolve ANTHROPIC_AUTH_TOKEN." >&2
    return 1
  }

  ANTHROPIC_BASE_URL="https://api.z.ai/api/anthropic" ANTHROPIC_AUTH_TOKEN="$token" "${cmd[@]}"
}

status_secret_value() {
  local pass_file="$1"
  local key="$2"
  local label="$3"
  local pass_ref="$4"
  local env_file
  local ref

  if [ -f "$pass_file" ]; then
    env_file="$(select_secret_env_file "$pass_file" "$label")" || return 1
    ref="$(env_file_value "$env_file" "$key")"

    if [ -z "$ref" ]; then
      echo "[ng] $label is missing in $env_file."
      return 1
    fi

    if resolve_secret_ref "$ref" "$label" >/dev/null 2>&1; then
      echo "[ok] $label resolves from $env_file."
      return 0
    fi

    echo "[ng] $label failed to resolve from $env_file ($ref)."
    return 1
  fi

  ref="$(select_secret_ref "$pass_ref" "${label}_REF")" || return 1
  if resolve_secret_ref "$ref" "$label" >/dev/null 2>&1; then
    echo "[ok] $label resolves from shared ref ($ref)."
    return 0
  fi

  echo "[ng] $label failed to resolve from shared ref ($ref)."
  return 1
}

status_shared_ref() {
  local pass_ref="$1"
  local label="$2"
  local ref

  ref="$(select_secret_ref "$pass_ref" "$label")" || return 1

  if resolve_secret_ref "$ref" "$label" >/dev/null 2>&1; then
    echo "[ok] $label resolves ($ref)."
    return 0
  fi

  echo "[ng] $label failed to resolve ($ref)."
  return 1
}

secrets_status_core() {
  local ok=0

  if command -v pass-cli >/dev/null 2>&1; then
    echo "[ok] pass-cli is installed."
  else
    echo "[ng] pass-cli is not installed."
    ok=1
  fi

  if [ "${PROTON_PASS_KEY_PROVIDER-}" = "fs" ]; then
    echo "[ok] PROTON_PASS_KEY_PROVIDER=fs"
  else
    echo "[ng] PROTON_PASS_KEY_PROVIDER should be 'fs' (current: ${PROTON_PASS_KEY_PROVIDER:-unset})."
    ok=1
  fi

  if status_secret_value "$HOME/.config/proton-pass/claude.env" "ANTHROPIC_AUTH_TOKEN" "ANTHROPIC_AUTH_TOKEN" "$ANTHROPIC_AUTH_TOKEN_PASS_REF"; then
    true
  else
    ok=1
  fi

  return "$ok"
}

secrets_status() {
  local ok=0

  if secrets_status_core; then
    true
  else
    ok=1
  fi

  if status_shared_ref "$GOG_KEYRING_PASSWORD_PASS_REF" "GOG_KEYRING_PASSWORD_REF"; then
    true
  else
    ok=1
  fi

  if status_shared_ref "$CONTEXT7_API_KEY_PASS_REF" "CONTEXT7_API_KEY_REF"; then
    true
  else
    ok=1
  fi

  if status_shared_ref "$PUSHOVER_TOKEN_PASS_REF" "PUSHOVER_TOKEN_REF"; then
    true
  else
    ok=1
  fi

  if status_shared_ref "$PUSHOVER_USER_PASS_REF" "PUSHOVER_USER_REF"; then
    true
  else
    ok=1
  fi

  return "$ok"
}

gog_op() {
  local keyring_password

  if ! command -v gog >/dev/null 2>&1; then
    echo "gog CLI is required." >&2
    return 1
  fi

  keyring_password="$(resolve_secret_ref "$GOG_KEYRING_PASSWORD_PASS_REF" "GOG_KEYRING_PASSWORD")" || {
    echo "gog: failed to resolve GOG_KEYRING_PASSWORD." >&2
    return 1
  }

  GOG_KEYRING_PASSWORD="$keyring_password" gog "$@"
}

cx() {
  local context7_ref
  local context7_key

  context7_ref="$(select_secret_ref "$CONTEXT7_API_KEY_PASS_REF" "CONTEXT7_API_KEY_REF")" || return 1

  context7_key="$(resolve_secret_ref "$context7_ref" "CONTEXT7_API_KEY_REF")" || {
    echo "cx: failed to resolve CONTEXT7_API_KEY." >&2
    return 1
  }

  CONTEXT7_API_KEY="$context7_key" codex "$@"
}

# Alias
alias cl="clear"
alias zll="zellij"
alias zla="zellij a"
alias ..="cd ../"
alias ...="cd ../../"
alias cc="claude"
alias ccd="claude --dangerously-skip-permissions"
alias secrets-status="secrets_status"
alias gog="gog_op"
alias mr="mise run"
alias phc="phantom create"
alias phd="phantom delete"
alias phs="phantom shell"
alias python="python3"
alias opencode="OPENCODE_EXPERIMENTAL_PLAN_MODE=true opencode"

# bun completions
[ -s "$HOME/.bun/_bun" ] && source "$HOME/.bun/_bun"

# pnpm completions
if command -v pnpm &> /dev/null; then
  eval "$(pnpm completion zsh)";
fi

# jujutsu completions
if command -v jj >/dev/null 2>&1; then
  source <(COMPLETE=zsh jj)
fi

# neovim
if [ -f "$HOME/apps/nvim-linux-arm64.appimage" ]; then
  alias nvim="$HOME/apps/nvim-linux-arm64.appimage"
fi

# Zellij custom
zll_new_git_wt() {
  # zellij 内でなければ終了
  if [ -z "${ZELLIJ-}" ]; then
    echo 'zj_new_tab: must be run inside zellij' >&2
    return 1
  fi

  # ブランチ名を受け取る
  local name="$1"

  if [ -z "$name" ]; then
    printf 'tab name: '
    read -r name || return 1
  fi

  [ -z "$name" ] && return 1

  phantom create "feature/$name"

  # Layout の作業領域が2ペイン前提
  local cwd="$PWD"
  zellij action new-tab --name "$name" --layout main --cwd "$cwd"

  zellij action write-chars "phantom shell feature/$name"
  zellij action write 13

  zellij action focus-next-pane
  zellij action write-chars "phantom shell feature/$name"
  zellij action write 13

  zellij action focus-previous-pane
  zellij action write-chars "codex"
  zellij action write 13
}
